#include "affiche_tas.h"
#include <stddef.h>
#include <string.h>
#include<stdio.h>


char tas[TAILTAS  +1];
int libre;

/* A COMPLETER */

int first_fit (unsigned int taille, int* pred){
  //Implémente une stratégie de first fit sur notre tas pour trouver le block à allouer
  int block_libre_courant = libre;
  while ( (block_libre_courant != -1) && (tas[block_libre_courant] <= taille) ){    //On parcourt la liste des blocks libres : si on trouve un block de la bonne taille, on sort de la boucle
    *pred = block_libre_courant;
    block_libre_courant = tas[block_libre_courant+1];       //La case suivant celle indexée par block_libre_courant nous donne le block libre suivant
  }

  return block_libre_courant;   //S'il vaut -1, on n'a rien trouvé, sinon, on a trouvé et on retourne l'indice
}

char* tas_malloc(unsigned int taille){

  int pred = -1;
  int position_block = first_fit(taille, &pred);

  if (position_block == -1){
    return NULL;    //Pas assez de place dans le tas !
  }

  int next_vide = tas[position_block+1];    //on récupère le block vide suivant pour maintenir le chaînage

  if ((tas[position_block] - taille ) >=2){     //On a assez de place pour refaire un block vide
    int debut_new_bloc_vide = position_block + taille + 1;      //Indice du début du nouveau block libre
    tas[debut_new_bloc_vide] = tas[position_block] - taille -1;    // Taille de de nouveau block libre
    tas[debut_new_bloc_vide+1] = next_vide;                     //Chaînage avec le suivant
    if (pred != -1){
      tas[pred + 1] = debut_new_bloc_vide;  //À ne pas faire quand il n'y a pas de précédent !
    }
    else{
      libre = debut_new_bloc_vide;           //S'il n'y a pas de précédent, c'est le premier block libre !
    }
  }
  else{
    if(pred != -1){
      tas[pred +1] = tas[position_block + 1];       //On continue le chaînage en prenant le block suivant de celui qu'on alloue
    }
    else{
      libre = tas[position_block+1];                //S'il n'y a pas de précédent, le block suivant devient le premier block libre
    }
  }
  tas[position_block] = taille;
  return tas + position_block +1;              //On retourne l'adresse de début du block alloué dans le tas
}


int tas_free(char* ptr){
  ptr[0] = libre ;      //On ajoute le block libre en tête de la liste de blocks vides
  libre = (int) (ptr - tas -1);     // Le nouveau block libre de tête de liste est celui qu'on vient d'ajouter
  return 1;
}

int main() {
  tas_init();

  char *p1, *p2, *p3, *p4;
  p1 = (char *) tas_malloc(10);
  afficher_tas();
  p2 = (char *) tas_malloc(9);
  afficher_tas();
  p3 = (char *) tas_malloc(5);
  afficher_tas();
  strcpy( p1, "tp 1" );
  strcpy( p2, "tp 2" );
  strcpy( p3, "tp 3" );

  tas_free( p2 );
  afficher_tas();
  p4 = (char *) tas_malloc(8);
  strcpy( p4, "systeme" );

  afficher_tas();
}


