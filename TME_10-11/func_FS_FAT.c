#include "fat.h"
#include <string.h>
#include <assert.h>
#include <stdio.h>

int file_found (char * file ) {
  int i;
  struct ent_dir * pt = pt_DIR;

  for (i=0; i< NB_DIR; i++) {
    if ((pt->del_flag) && (!strcmp (pt->name, file))) 
      return 0;
    pt++;
  }
  /* finchier n'existe pas */
  return 1;
}


void list_fat () {
  int i;
  short *pt = pt_FAT;
  for (i=0; i < NB_ENT_FAT; i++) {
    if (*pt)
      printf ("%d ",i);
    pt++;
  }
  printf ("\n");
}

void afficher_liste_blocks(short first_block, short last_block){
  short *pt = pt_FAT;
  short i = first_block;
  int cpt = 0;
  do {
    printf("%d ",i);
    i = pt[i];
    cpt ++;
  }while (i !=last_block);
  printf("%d\t (%d blocks)\n",i,cpt+1);
}

void list_dir ( ) {
  int i;
  struct ent_dir * pt = pt_DIR;
  int cpt = 0;
  printf("\tNom \t\tTaille  Blocks\n\n");
  for (i=0; i< NB_DIR; i++) {
    if (pt->del_flag){
      printf("\t%s \t%d\t",pt->name,pt->size);
      if (pt->size > 0){      //Il y a des blocs dans la FAT.
        afficher_liste_blocks(pt->first_bloc,pt->last_bloc);
      }
      else{
        printf("\n");
      }
      cpt++;
    }
    pt++;
  }
  printf("\nIl y avait %d fichiers\n",cpt);
}

int mv_file (char*file1, char *file2) {
  int i;
  struct ent_dir * pt = pt_DIR;
  for (i=0; i< NB_DIR; i++) {
    if ((pt->del_flag) && (!strcmp(pt->name,file1))){
      strcpy(pt->name,file2);
      if (write_DIR_FAT_sectors()== -1){
        printf("Erreur d'écriture\n");
        return -1;
      }
      return 0;
    }
    pt++;
  }
  return -1;
}


int cat_file (char* file) {
  int i;
  char buffer[129];
  struct ent_dir * pt = pt_DIR;
  for (i=0; i< NB_DIR; i++) {
    if ((pt->del_flag) && (!strcmp(pt->name,file))){
      /*Ici on a trouvé le fichier*/

      /*Parcours des blocks*/
      short *pt_fat = pt_FAT;
      short i = pt->first_bloc;
      short c = pt->first_bloc;
      do{
        if(read_sector(i,buffer)== -1){
          return -1;
        }
        printf("%s\n\n",buffer);
        c = i;
        i = pt_fat[i];
      }while (c != pt->last_bloc);

      return 0;
    }
    pt++;
  }
  return -1;
}


int delete_file (char* file)
{
  int i;
  struct ent_dir* pt = pt_DIR;

  for(i = 0; i< NB_DIR; i++){
    if( (pt->del_flag) && (!strcmp(pt->name, file))){
      /*Libérer les blocs*/

      short* pt_fat = pt_FAT;
      short i = (pt->first_bloc);
      short condition = (pt->first_bloc);

      do{
        condition = i;
        i = pt_fat[i];
        pt_fat[condition] = 0;
      }while(condition != pt->last_bloc);

      /*Effacer le fichier*/
      pt->del_flag = 0;
      if(write_DIR_FAT_sectors()== -1){
        return -1;
      }
      return 0;
    }
    pt++;
  } 
  return -1;
}

int create_file (char *file) {
  if(file_found(file)==0){
    /*Fichier déjà existant*/
    return -1;
  }
  int i;
  struct ent_dir* pt = pt_DIR;

  for(i = 0; i< NB_DIR; i++){
    if( (pt->del_flag==0)){
      pt->del_flag = 1;
      pt->size = 0;
      strcpy(pt->name,file);
      pt->first_bloc = -1;
      pt->last_bloc = -1;
    
      if(write_DIR_FAT_sectors()== -1){
            return -1;
      }
      return 0;
    }
    pt++;
  } 
  return -1;
}


short alloc_bloc () { 
  int i;
  short *pt = pt_FAT;
  for (i=0; i < NB_ENT_FAT; i++) {
    if (*pt == 0){
      *pt = -1;

      if(write_DIR_FAT_sectors()== -1){
        return -1;
      }
      return i;
    }
    pt++;
  }
  return -1;
}
 	
int append_file  (char*file, char *buffer, short size) { 

  int i;
  struct ent_dir * pt = pt_DIR;
  short bloc_ajout;
  short* pt_fat = pt_FAT;
  char* txt = buffer;
  char bloc[129];
  int taille_ajout = 0;
  int reste;
  for(i = 0; i< NB_DIR; i++){
    if( (pt->del_flag) && (!strcmp(pt->name, file))){
      /*On a trouvé le fichier*/
      /*On écrit dans chaque bloc ce qu'il faut depuis le buffer*/

      if(pt->size%128!=0){  //Cas où on doit remplir le dernier bloc
        bloc_ajout = pt->last_bloc;
        read_sector(bloc_ajout,bloc);
        for (short c = (pt->size)%128; c < 128;c++){
          bloc[c] = *(txt);          //On copie le buffer dans la place disponible dans le bloc
          txt++;
          taille_ajout++;
          if (taille_ajout == size){//On a copié tout le buffer
            break;
          }
        }
        bloc[128] = '\0'; 
        if (write_sector(bloc_ajout,bloc) == -1){
          return -1;
        }
      }
      pt->size += size;

      reste = size - taille_ajout;      //Il reste à écrire des données
      while(reste > 0){
        bloc_ajout = alloc_bloc();      //Nouveau dernier bloc
        if(bloc_ajout == -1){
          return -1;    //Plus de place dans la FAT
        }
        if(pt->size == 0){            //On a aucun bloc pour ce fichier
          pt->first_bloc = bloc_ajout;
        }
        else{
          pt_fat[pt->last_bloc] = bloc_ajout;     //On maintient le chaînage
        }
        pt->last_bloc = bloc_ajout;             //Le bloc ajouté est le nouveau dernier !
        
        /*On écrit sur notre bloc*/
        if (write_sector(bloc_ajout,txt) == -1){
          return -1;
        }
        txt = txt + 128;        //On avance par pas de 128 dans les données.
        reste = reste -128;     //On vient d'écrire possiblement 128 données (si moins, on aura un résultat négatif qui fera sortir de la boucle)
      }
      
      if(write_DIR_FAT_sectors()== -1){     //On met à jour la FAT sur le disque
        return -1;
      }
      
      return 0;
    }
    pt++;
  } 
  /*On n'a pas trouvé le fichier où écrire*/
  return -1;

}



struct ent_dir*  read_dir (struct ent_dir *pt_ent ) {
  /* A COMPLETER */  
}