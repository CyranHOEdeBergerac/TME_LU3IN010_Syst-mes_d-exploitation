#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <sched.h>

#define LONGTIME 8E8
void ProcLong(int *);
void ProcCourt(int *);

int Compte_election = 0;

// Exemple de processus long (une simple bouble),
// Chaque processus long cr�e a son tour 4 processus courts
//
void ProcLong(int *pid) {
  long i;
  static int cpt = 0;

  for (i=0;i<LONGTIME;i++) {
    if (i%(long)(LONGTIME/4) == 0)  {
      int *tcpt = (int *) malloc(sizeof(int));
      *tcpt = cpt;
      CreateProc((function_t)ProcCourt,(void *)tcpt, 10);
      cpt++;
    }
    if (i%(long)(LONGTIME/100) == 0)
      printf("Proc. Long %d - %ld\n",*pid, i);
  }
  printf("############ FIN LONG %d\n\n", *pid );
}


// Processus court
void ProcCourt(int *pid) {
  long i;

  for (i=0;i<LONGTIME/10;i++)
    if (i%(long)(LONGTIME/100) == 0)
      printf("Proc. Court %d - %ld\n",*pid, i);
  printf("############ FIN COURT %d\n\n", *pid );
}




// Exemples de primitive d'election definie par l'utilisateur
// Remarques : les primitives d'election sont appel�es directement
//             depuis la librairie. Elles ne sont app�l�es que si au
//             moins un processus est � l'etat pret (RUN)
//             Ces primitives manipulent la table globale des processus
//             d�finie dans sched.h


// Election al�atoire
int RandomElect(void) {
  int i;

  printf("RANDOM Election !\n");

  do {
    i = (int) ((float)MAXPROC*rand()/(RAND_MAX+1.0));
  } while (Tproc[i].flag != RUN);

  return i;
}


// Election de SJF "Shortest Job Fisrt"
int SJFElect(void) {
  /* Choisir le processus p  - A ecrire en TP */

  int i = 0;
  int min;

  while( (i < MAXPROC) && Tproc[i].flag != RUN){
    i++;
  }

  if(i == MAXPROC){
    return -1;        //On a pas trouvé de processus dans l'état RUN
  }

  min = i;
  for ( ; i < MAXPROC ; i++){
    if ((Tproc[i].flag == RUN) && (Tproc[i].duration < Tproc[min].duration)){
      min = i;
    }
  }
  return min;	
}

// Approximation SJF
int ApproxSJF(void) {

  /* Choisir le processus p - A ecrire en TP */
  int i = 0;
  int min;

  while( (i < MAXPROC) && Tproc[i].flag != RUN){
    i++;
  }

  if(i == MAXPROC){
    return -1;        //On a pas trouvé de processus dans l'état RUN
  }

  min = i;
  for ( ; i < MAXPROC ; i++){
    if ((Tproc[i].flag == RUN) && (Tproc[i].ncpu < Tproc[min].ncpu)){
      min = i;
    }
  }
  return min;	

}


// Approximation SJF bis (prend en compte la famine)
int ApproxSJF_bis(void) {


  /* Choisir le processus p - A ecrire en TP */
  int i = GetElecProc();
  int min;
  int cpt = 0;

  while( (cpt < MAXPROC) && Tproc[i].flag != RUN){
    cpt++;
    i = (i+1) % MAXPROC;
  }

  if(i == MAXPROC){
    return -1;        //On a pas trouvé de processus dans l'état RUN
  }

  min = i;
  for ( ; cpt < MAXPROC ; cpt++){

    Tproc[i].prio = Tproc[i].prio - 2*Tproc[i].ncpu;

    if(Compte_election == 10){
      Tproc[i].prio = (Tproc[i].prio + 10 >= MAXPRIO ? MAXPRIO : Tproc[i].prio + 10);
    }

    if ((Tproc[i].flag == RUN) && (Tproc[i].prio < Tproc[min].prio)){
      min = i;
    }


    i = (i +1) % MAXPROC;
  }

  if (Compte_election == 10){
    Compte_election = 0;
  }
  else {
    Compte_election ++;
  }
  return min;	

}


int main (int argc, char *argv[]) {
  int i;
  int *j;  

  // Cr�er les processus long
  for  (i = 0; i < 2; i++) {
    j = (int *) malloc(sizeof(int));
    *j= i;
    CreateProc((function_t)ProcLong,(void *)j, 80);
  }



  // Definir une nouvelle primitive d'election avec un quantum de 0.5 seconde
  SchedParam(NEW, 0.1, ApproxSJF_bis);

  // Lancer l'ordonnanceur en mode non "verbeux"
  sched(0);     

  // Imprimer les statistiques
  PrintStat();

  return EXIT_SUCCESS;

}
