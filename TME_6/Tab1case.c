/* Diffusion tampon 1 case */

  #include <stdio.h> 
  #include <unistd.h> 
  #include <stdlib.h> 
  #include <signal.h> 
  #include "lib/libipc.h"

/************************************************************/

/* definition des parametres */ 

  #define NE          2     /*  Nombre d'emetteurs         */ 
  #define NR          5     /*  Nombre de recepteurs       */ 

/************************************************************/

/* definition des semaphores */ 

	#define EMET 5
  #define MUTEX_NB 6
  #define T_DEBUT 0
        
/************************************************************/

/* definition de la memoire partagee */ 

  typedef struct {
	int nb_recepteurs;
} t_segpart;

t_segpart *sp; 


/************************************************************/

/* variables globales */ 
    int emet_pid[NE], recep_pid[NR]; 

/************************************************************/

/* traitement de Ctrl-C */ 

  void handle_sigint(int sig) { 
      int i;
      for (i = 0; i < NE; i++) kill(emet_pid[i], SIGKILL); 
      for (i = 0; i < NR; i++) kill(recep_pid[i], SIGKILL); 
      det_sem(); 
      det_shm((char *)sp); 
  } 

/************************************************************/

/* fonction EMETTEUR */ 

	// A completer - contient les instructions executees
        // par un emetteur
  void emetteur(){

    while(1){
        P(EMET);
        printf("Je suis un émétteur et j'émets.\n");
        for (int j = 0 ; j < NR ; j++){
          V(T_DEBUT+ j);
        }
    }
    
  }
/************************************************************/

/* fonction RECEPTEUR */ 

	// A completer - contient les instructions executees
        // par un recepteur
  void recepteur(int i){
    while(1){
        P(T_DEBUT+i);
        printf("Je suis le récepteur %d et je reçois.\n",i);    
        P(MUTEX_NB);
          sp->nb_recepteurs ++;
          printf("%d ont reçu le message\n",sp->nb_recepteurs);
          if (sp->nb_recepteurs == NR){
            sp->nb_recepteurs = 0;
            V(EMET);
          }
        V(MUTEX_NB);
      }
  }
/************************************************************/

int main() { 
    struct sigaction action;
    /* autres variables (a completer) */
    int semid, pid;
    
    setbuf(stdout, NULL);

/* Creation du segment de memoire partagee */

	// A completer
  if ( (sp = (t_segpart *)init_shm(sizeof(t_segpart) ))== NULL) {
		perror("init_shm");
		exit(1);
	}

/* creation des semaphores */ 

  // A completer
	if ((semid = creer_sem(7)) == -1) {
                perror("creer_sem");
                exit(1);
        }

/* initialisation des semaphores */ 

	// A completer
  init_un_sem(MUTEX_NB,1);
  init_un_sem(EMET,1);

  int i;
  for(i = T_DEBUT ; i < NR ; i ++){
    init_un_sem(i,0);
  }

  sp->nb_recepteurs = 0;

/* creation des processus emetteurs */ 

	// A completer - les pid des processus crees doivent
        // etre stockes dans le tableau emet_pid
  
  for (i = 0 ; i < NE ; i++){
    emet_pid[i] = fork();
    if(emet_pid[i]== 0){
      emetteur();
      exit(0);
    }
  }

/* creation des processus recepteurs */ 

	// A completer - les pid des processus crees doivent
        // etre stockes dans le tableau recep_pid

  for (i = 0 ; i < NR ; i++){
    recep_pid[i] = fork();
    if(recep_pid[i]==0){
      recepteur(i);
      exit(0);
    }
  }



/* redefinition du traitement de Ctrl-C pour arreter le programme */ 

    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    action.sa_handler = handle_sigint;
    sigaction(SIGINT, &action, 0); 
    
    pause();                    /* attente du Ctrl-C  */
    return EXIT_SUCCESS;
} 
